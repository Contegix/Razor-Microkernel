There are two types of files that are not maintained under revision control
in this project at this time (Git does a pretty bad job when it comes to maintaining
multiple versions of large binary files. The first file (iso-build-files.tar.gz) is
built for each revision of the Microkernel and contains all of the files that are
needed to rebuild a new Microkernel ISO (i.e. a Microkernel ISO corresponding to
the one that we are using in the Razor project). Unpacking this file will result
in a directory structure that looks something like the following being created in
the current working directory:

                          microcore-current-files
                                   |
                                   |
                             tcl-4.2.1-files
                                   |
                                   |
                     -----------------------------
                     |             |             |
                     |             |             |
                   newiso       extract         tmp

In this directory structure, the "extract" subdirectory contains all of the
files that were extracted from the core.gz file that is contained in the
original Core-current.iso file from the Tiny Core Linux (v4.2.1) distribution.
The "tmp" directory, on the other hand, contains all of the files that were
used to create the customized version of this same core.gz file (the
customized version that appears in the Microkernel ISO that we are using in
Razor). The new core.gz file was then used to replace the file that appears
in the boot subdirectory of "newiso" subdirectory (which originally contained
a copy of the contents of the Core-current.iso file).  As such, the "newiso"
subdirectory contains all of the contents of the ISO file that we are using
in the Razor project.

If the iso-build-files.tar.gz tarfile is extracted, the within the
microcore-current-files directory that is created you will find a
tcl-4.2.1-files subdirectory contains a shell script (in addition to the three
directories mentioned above).  This shell script (rebuild_iso.sh) can be used
to build a new ISO after changes are made to the contents of the "tmp"
directory.  The rebuild_iso.sh script will run all of the appropriate commands
(there are about 8 of them) necessary to build a new verison of the core.gz
file, place it in the appropriate location in the newiso directory, and then
build the new ISO from the contents of that (newiso) directory. When the script
finishes, that new ISO can be used to boot machines (virtual or otherwise).

The second file is the Microkernel image itself (which is distributed in the
form of an ISO).  There are two versions of Tiny Core Linux that have been
used to build this image file, the current release is based on TCL v4.2.1
In addition to the Ruby scripts that are maintained in this project, each
Microkernel image in this includes the following extensions to the "stock"
Tiny Core Linux distro that it was built from:

        1. Ruby (v1.8.7)
        2. Bash
        3. OpenSSH (v5.8p1)
        4. MCollective (v1.2.1)
        5. RubyGems (v1.8.15)
        6. dmidecode (v2.11)  <- (Added in v0.0.2.0)

When these ISOs are used as the boot image for a node, scripts will
automatically be run after the node boots that will start an SSH daemon
and the MCollective daemon, a WEBrick instance, and the Microkernel
Controller daemon.  Once the MCollective daemon is started, the node
can be controllable from an MCollective Control Node.

At this time, the MCollective daemon's configuration (which appears in the
/usr/local/etc/mcollective directory of the Microkernel's filesystem) is
"hard-coded" into the ISO, as is the public/private host key pair that
is used by the SSH daemon.  The "fixed" public/private host key pair
(which is the same for all Microkernel instances based on the current ISO)
isn't really an issue, because this service will be pulled out of any
Microkernel ISO that is rolled out into a production environment (to
prevent command-line access to the nodes when they are being managed by
the Microkernel).

In addition to the extensions that were mentioned previously, we have also made
the following changes to the "stock" Tiny Core Linux distro when building out
the current version of the Razor Microkernel (v0.2.0.0):

        1. We have reduced the boot prompt timeout (defined in the
           /boot/isolinux/isolinux.cfg file in the ISO itself) to
           approximately 10 seconds (the original value was 30 seconds)

        2. We have modified the /opt/bootlocal.sh script that is include
           in the microcore.gz file used by the Microkernel (which can be
           found in the ISO's /boot directory) so that when the Microkernel
           is booted it will automatically:

                a. Starts the SSH daemon
                b. Installs the Bundler RubyGem
                c. Uses the Bundler RubyGem to install the stomp, facter,
                   daemons, json_pure, and bluepill bundles
                d. Run a Ruby-based initialization script that completes
                   the process of setting up the Microkernel for use

           This initialization script (rz_mk_init.rb) changes the
           hostname (in the /etc/hosts and /etc/hostname files using the 'sed'
           command and also logically using the 'hostname' command), then
           starts a Ruby-based Microkernel Controller daemon, a Ruby-based
           Web Server (a WEBrick instance), and the MCollective daemon.
           These tasks are only run after the Microkernel's network has been
           initialized (which can take several seconds after the boot process
           completes), in order to ensure that MAC address for the 'eth0'
           adapter is available through Facter and the that the MCollective
           agent and Microkernel Controller will be able to communicate with
           the Razor Server/MCollective Control Node.

         3. We have added a pair of MCollective agents to the
            /usr/local/mcollective/plugins/mcollective/agent subdirectory.
            One agent is a test agent that simply echos back the message
            sent to it, along with the time that message was receive. The
            second agent (facteragent.rb) provides access to "Facter" on
            each instance of the Microkernel through the MCollective.

         4. The Microkernel Controller (mentioned in #2, above) is basically
            just a wrapper script (rz_mk_controller.rb) that has been placed
            around the real (rz_mk_control_server.rb) Microkernel Controller
            script in order to daemonize the latter script and provide for
            easy control over the latter script from the command line.  The
            usage for the "Microkernel Controller" script is as follows:

            Usage: rz_mk_controller.rb <command> <options> -- <application options>

            * where <command> is one of:
              start         start an instance of the application
              stop          stop all instances of the application
              restart       stop all instances and restart them afterwards
              reload        send a SIGHUP to all instances of the application
              run           start the application and stay on top
              zap           set the application to a stopped state
              status        show status (PID) of application instances

            * and where <options> may contain several of the following:

                -t, --ontop                      Stay on top (does not daemonize)
                -f, --force                      Force operation
                -n, --no_wait                    Do not wait for processes to stop

            Common options:
                -h, --help                       Show this message
                    --version                    Show version

            As you can see, options are provided to start, stop, restart, reload,
            and check the status of the underlying rz_mk_controller process.

         5. We added an MCollective agent (the Configuration agent) to the
            Microkernel.  Currently, this agent has one action defined
            (send_mk_config) but additional actions could be added in the
            future.  The "send_mk_config" action takes one argument
            (which MUST be a JSON-ized version of the configuration being
            passed to the managed node) and passes that string to the WEBrick
            instance running on the node via a POST operation. If the
            configuration received is different from the current configuration
            for the controller, then the WEBrick saves the new configuration
            to a file and restarts the Microkernel Controller.  This forces an
            update to the Microkernel Controller's configuration.

         6. One of the Microkernel Controller configuration options is a
            pattern that defines which of the Facter "facts" (if any) should
            be excluded from the registration details that are passed to the
            Razor server by the Microkernel Controller.  Currently, only
            "facts" that have names that start with the string "uptime" or
            "memory" are excluded, but this could be changed later.

         7. The Microkernel Controller periodically checks in with the
            Razor server, and the periodicity of this "checkin" action being
            set as part of the Microkernel Controller's configuration (the
            initial periodicity that is "burned into" the ISO (which can be
            overridden later) is 60 seconds.  This "checkin" takes the form
            of a POST to the Razor Server, and the Razor Server replies with
            an action that the Microkernel Controller should take (currently,
            the only actions supported are an "Acknowledgement", which
            results in no action, a "Register", which causes the node to
            Register with the Razor Server, and a "Reboot", which causes
            a reboot of the node immediately.

            During the Registration process, the node POSTs a JSON-formatted
            string representation of the facts discovered using Facter to the
            registration URI received as part of it's configuration.  This
            "registration" procedure will also be triggered any time that the
            Microkernel Controller detects a change in the facts that it has
            gathered (versus the facts last reported to the Razor server using
            this same registration procedure).

            The initial "checkin" that the node makes is back to the
            "next-server" that the node used during the iPXE-boot process.
            Typically, this initial "checkin" will trigger a registration and,
            possibly, a restart of the Microkernel Controller when the initial
            configuration is received from the Razor Server in the reply to the
            initial checkin-message.  If the configuration changes from one
            checkin to the next, then the Microkernel Controller will POST the
            new configuration to the Microkernel Web Server, which will save
            the new configuration and restart the Microkernel Controller.
            This functionality could also be triggered via the MCollective
            (using the configuration agent that is included in the Microkernel
            ISO), and an example script is included to show how this might
            be done from within a Ruby script (the 'test-configuration.rb'
            script, which can be found in the 'configuration-agent'
            subdirectory of this project).  An example of using this
            script from the command line is something like the following:

            # test-configuration.rb mk_conf.yaml

            This command tells all of the configuration-agents to use the
            contents of the mk_conf.yaml file as the new configuration for
            their Microkernel Controller.  An example of this YAML file is
            included in this project.  The fields contained in that example
            file are all REQUIRED fields (and some may need to be changed
            to reflect the local network that the Razor server has been
            instantiated in.

All of these changes (and the procedure that was followed to make them) can be
found in the following pages:

        1. Remastering the Microkernel ISO:

        http://dcade.lss.emc.com/confluence/display/ASI/Remastering+the+Microkernel+ISO

        2. Reconfiguring the Microkernel to include the "extras" that are
           described above:

        http://dcade.lss.emc.com/confluence/display/ASI/Microkernel+Configuration

        3. Configuring an MCollective Agent

        http://dcade.lss.emc.com/confluence/display/ASI/Configuring+an+MCollective+Agent